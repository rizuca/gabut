<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Bomber Petualangan</title>
    <link rel="icon" href="img/bomlogo.png">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <!-- <link rel="stylesheet" href="style.css"> -->
    <style>
        /* General Body and Font Styles */
body {
    display: flex;
    flex-direction: column;
    justify-content: center; /* Center content vertically */
    align-items: center;
    min-height: 100vh;
    background-color: #000; /* Base for star background */
    margin: 0;
    padding: 5px;
    font-family: 'Press Start 2P', cursive;
    color: #ECEFF1;
    overflow: hidden; /* Prevent scrollbars from star animations */
    box-sizing: border-box;
}

/* Starry Night Background for Character Selection */
.stars-bg {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1; /* Behind other content */
    overflow: hidden;
}

.stars-bg.hidden {
    display: none;
}

/* Create multiple layers of stars for parallax effect */
.stars-bg .stars1, .stars-bg .stars2, .stars-bg .stars3 {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-repeat: repeat;
    background-size: cover; /* Or a fixed size like 256px 256px if using a tile */
}

/* Base star image (small dot) */
.stars-bg .stars1 {
    background-image: radial-gradient(1px 1px at 20px 30px, #eee, rgba(0,0,0,0)),
                      radial-gradient(1px 1px at 40px 70px, #fff, rgba(0,0,0,0)),
                      radial-gradient(1px 1px at 50px 160px, #ddd, rgba(0,0,0,0)),
                      radial-gradient(2px 2px at 90px 40px, #fff, rgba(0,0,0,0)),
                      radial-gradient(2px 2px at 130px 80px, #fff, rgba(0,0,0,0)),
                      radial-gradient(2px 2px at 160px 120px, #ddd, rgba(0,0,0,0));
    animation: moveStars1 150s linear infinite;
}

.stars-bg .stars2 {
    background-image: radial-gradient(1px 1px at 10px 50px, #eee, rgba(0,0,0,0)),
                      radial-gradient(1px 1px at 80px 30px, #fff, rgba(0,0,0,0)),
                      radial-gradient(2px 2px at 60px 140px, #ddd, rgba(0,0,0,0)),
                      radial-gradient(2px 2px at 120px 100px, #fff, rgba(0,0,0,0)),
                      radial-gradient(3px 3px at 150px 50px, #fff, rgba(0,0,0,0)),
                      radial-gradient(3px 3px at 180px 150px, #ddd, rgba(0,0,0,0));
    animation: moveStars2 100s linear infinite;
}
.stars-bg .stars3 {
    background-image: radial-gradient(2px 2px at 30px 20px, #eee, rgba(0,0,0,0)),
                      radial-gradient(2px 2px at 70px 90px, #fff, rgba(0,0,0,0)),
                      radial-gradient(3px 3px at 100px 180px, #ddd, rgba(0,0,0,0)),
                      radial-gradient(3px 3px at 140px 60px, #fff, rgba(0,0,0,0));
    animation: moveStars3 75s linear infinite;
}


@keyframes moveStars1 {
    from { transform: translateY(0px); }
    to { transform: translateY(-1000px); }
}
@keyframes moveStars2 {
    from { transform: translateY(0px); }
    to { transform: translateY(-1000px); }
}
@keyframes moveStars3 {
    from { transform: translateY(0px); }
    to { transform: translateY(-1000px); }
}

/* Character Selection Screen */
#characterSelectionScreen {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 20px;
    width: 100%;
    max-width: 600px; 
    min-height: 300px;
    box-sizing: border-box;
    background-color: rgba(10, 20, 30, 0.75); /* Slightly more opaque */
    border-radius: 20px;
    box-shadow: 0 0 40px rgba(70, 130, 180, 0.7);
    margin: auto;
    position: relative;
    z-index: 1;
}


#characterSelectionScreen h2 {
    font-size: 1.5rem; 
    margin-bottom: 25px;
    color: #FFD700; 
    text-shadow: 2px 2px 4px #000;
}

.character-options-container {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap; 
}

.character-option img {
    width: 80px; 
    height: 80px;
    object-fit: contain;
    border: 4px solid transparent;
    border-radius: 15px;
    margin: 10px;
    cursor: pointer;
    transition: border-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
    background-color: rgba(255,255,255,0.15); 
}

.character-option img:hover {
    border-color: #00FFFF;
    transform: scale(1.2); 
    box-shadow: 0 0 20px #00FFFF;
}

.character-option img.selected {
    border-color: #39FF14;
    transform: scale(1.35) rotate(7deg) translateY(-8px); 
    box-shadow: 0 0 30px #39FF14, 0 0 45px #39FF14, inset 0 0 15px rgba(57,255,20,0.4);
}

/* Game Screen */
#gameScreen {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    box-sizing: border-box;
    background: linear-gradient(to bottom, #263238, #455A64);
    padding-top: 10px;
}

#gameInfo {
    margin-bottom: 10px; 
    font-size: 0.8rem; 
    text-align: center;
    color: #CFD8DC;
    width: 95%;
    max-width: 500px;
    background-color: rgba(0,0,0,0.3);
    padding: 8px;
    border-radius: 8px;
}

#gameInfo p {
    margin: 3px 0;
}

/* Game Board and Cells */
#gameBoard {
    display: grid; 
    border: 4px solid #78909C;
    box-shadow: 0 0 15px rgba(0,0,0, 0.5); 
    background-color: #37474F; 
    margin: 0 auto 10px auto;
    touch-action: none; 
}

.cell {
    display: flex;
    justify-content: center;
    align-items: center;
    border: 1px solid #546E7A; 
    position: relative; 
    box-sizing: border-box;
    overflow: hidden; 
}

.cell img { 
    max-width: 90%;
    max-height: 90%;
    object-fit: contain;
    image-rendering: pixelated; 
}

.wall {
    background-color: #4E342E; 
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 40 40'%3E%3Crect width='40' height='40' fill='%234E342E'/%3E%3Cpath d='M0 10h40M0 30h40M10 0v40M30 0v40' stroke='%233E2723' stroke-width='2'/%3E%3C/svg%3E");
    background-size: cover; 
}

.destructible-wall {
    background-color: #795548; 
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='40' viewBox='0 0 40 40'%3E%3Crect width='40' height='40' fill='%23795548'/%3E%3Crect x='5' y='5' width='30' height='30' fill='%238D6E63'/%3E%3Cpath d='M0 0L40 40M40 0L0 40' stroke='%235D4037' stroke-width='1.5' opacity='0.5'/%3E%3C/svg%3E");
    background-size: cover;
}

.bomb {
    animation: pulseBomb 0.4s infinite alternate;
    color: #FFFF00;
    text-shadow: 1px 1px 3px black;
    font-weight: bold;
}

.explosion {
    background-color: #FF9800; 
    opacity: 0.9; 
    animation: fadeOutExplosion 0.35s forwards; 
    border-radius: 30%; 
    box-shadow: 0 0 10px #FF5722, inset 0 0 5px #FFC107; 
}

.item {
    animation: floatItem 1.3s ease-in-out infinite alternate;
    text-shadow: 1px 1px 1px rgba(0,0,0,0.7);
}

/* Animations */
@keyframes floatItem {
    from { transform: translateY(-1px) scale(1); } 
    to { transform: translateY(1px) scale(1.05); }
}

@keyframes pulseBomb {
    from { transform: scale(1); filter: brightness(1); }
    to { transform: scale(1.25) rotate(3deg); filter: brightness(1.3); } 
}

@keyframes fadeOutExplosion {
    0% { opacity: 0.9; transform: scale(0.5); } 
    50% { opacity: 0.7; transform: scale(1.3); } 
    100% { opacity: 0; transform: scale(0.8); } 
}

/* Controls */
#controls {
    margin-top: 10px;
    text-align: center;
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center; 
    flex-wrap: wrap;
    width: 100%;
    max-width: 400px; 
}

.control-button, .action-button {
    background-color: #00BCD4;
    color: white;
    border: none;
    padding: 10px 12px; 
    margin: 4px;        
    border-radius: 8px;
    font-family: 'Press Start 2P', cursive;
    cursor: pointer;
    box-shadow: 0 3px #00796B;
    transition: all 0.1s ease;
    font-size: 0.75rem; 
    line-height: 1.2; 
    min-width: 40px; 
    min-height: 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    -webkit-tap-highlight-color: transparent; 
}

.control-button:active, .action-button:active {
    transform: translateY(2px);
    box-shadow: 0 1px #00796B;
}

.action-button { 
    background-color: #8BC34A;
    box-shadow: 0 3px #558B2F;
    font-size: 0.9rem;
    padding: 12px 18px;
    margin-top: 20px; 
}

.restart-button { /* This class is now on the button inside the modal */
    background-color: #F44336 !important; 
    box-shadow: 0 3px #C62828 !important;
    font-size: 0.9rem !important;
    margin-top: 15px; /* Spacing within the modal */
}


/* Message Area (for general in-game messages) */
#messageArea {
    margin-top: 10px;
    min-height: 35px; 
    color: #FFEB3B; 
    text-align: center;
    font-size: 0.8rem;
    width: 100%;
    max-width: 450px;
    padding: 6px;
    box-sizing: border-box;
    /* Ensure it doesn't overlap with a full-screen modal */
    position: relative; 
    z-index: 5; /* Above game board, below modal */
}

/* Game Over Modal Styles */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.75); /* Darker overlay */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000; /* Highest z-index to be on top */
}

.modal-overlay.hidden {
    display: none !important;
}

.modal-content {
    display: flex; /* DITAMBAHKAN */
    flex-direction: column; /* DITAMBAHKAN */
    align-items: center; /* DITAMBAHKAN: Ini akan memusatkan tombol */
    background-color: #263238; /* Dark slate grey */
    padding: 25px 30px;
    border-radius: 15px;
    box-shadow: 0 5px 25px rgba(0,0,0,0.5);
    text-align: center;
    border: 3px solid #455A64;
    width: 90%;
    max-width: 400px;
    color: #ECEFF1;
}

.modal-content h3 {
    font-size: 1.4rem;
    margin-top: 0;
    margin-bottom: 10px;
    /* Color will be set by JS based on win/loss */
}

.modal-content p {
    font-size: 1rem;
    margin-bottom: 20px;
    color: #CFD8DC;
}


/* Utility Classes */
.hidden {
    display: none !important;
}

/* Responsive Adjustments for Mobile */
@media (max-width: 600px) {
    #characterSelectionScreen h2 {
        font-size: 1.3rem;
    }
    .character-option img {
        width: 70px;
        height: 70px;
        margin: 6px;
    }
    .action-button { /* General action buttons */
        font-size: 0.8rem;
        padding: 10px 18px;
    }
     .modal-content #restartGameButton { /* Specific for restart button in modal */
        font-size: 0.9rem !important; /* Ensure it's easily tappable */
        padding: 12px 20px !important;
    }


    #gameInfo {
        font-size: 0.7rem; 
        padding: 4px;
    }
    #gameInfo p {
        margin: 1px 0;
    }

    .control-button {
        font-size: 1.3rem; /* Icon size */
        padding: 12px; 
        min-width: 48px; 
        min-height: 48px;
        margin: 3px;
    }
    #controls {
        max-width: 100%; 
        padding: 0 5px; 
        box-sizing: border-box;
    }

    #messageArea {
        font-size: 0.75rem;
        min-height: 30px;
    }

    .modal-content h3 {
        font-size: 1.2rem;
    }
    .modal-content p {
        font-size: 0.9rem;
    }
}

@media (max-width: 420px) { 
     #characterSelectionScreen h2 {
        font-size: 1.1rem;
    }
    .character-option img {
        width: 60px;
        height: 60px;
    }
    #gameInfo {
        font-size: 0.6rem;
    }
    .control-button {
        font-size: 1.1rem; 
        min-width: 40px;
        min-height: 40px;
        padding: 10px;
        margin: 2px;
    }
     #messageArea {
        font-size: 0.7rem;
    }
    .modal-content h3 {
        font-size: 1.1rem;
    }
    .modal-content p {
        font-size: 0.8rem;
    }
    .modal-content #restartGameButton {
        font-size: 0.8rem !important;
        padding: 10px 15px !important;
    }
}
    </style>
</head>
<body>
    <!-- Background for stars, only visible with character selection -->
    <div id="starsBackground" class="stars-bg">
        <div class="stars1"></div>
        <div class="stars2"></div>
        <div class="stars3"></div>
    </div>

    <div id="characterSelectionScreen">
        <h2>Pilih Karaktermu!</h2>
        <div class="character-options-container">
            <div class="character-option">
                <img src="img/char1.png" alt="Karakter 1" data-char="char1" onerror="this.onerror=null;this.src='https://placehold.co/80x80/263238/ECEFF1?text=Char1';">
            </div>
            <div class="character-option">
                <img src="img/char2.png" alt="Karakter 2" data-char="char2" onerror="this.onerror=null;this.src='https://placehold.co/80x80/263238/ECEFF1?text=Char2';">
            </div>
        </div>
        <button id="confirmCharacterButton" class="action-button hidden">Mulai Petualangan!</button>
    </div>

    <div id="gameScreen" class="hidden">
        <div id="gameInfo">
            <p>Bomber Petualangan</p>
            <p id="score">Skor: 0</p>
            <p>Bom: <span id="bombCount">1</span>/<span id="maxBombCount">1</span> | Kekuatan: <span id="bombStrength">1</span></p>
        </div>
        <div id="gameBoard"></div>
        <div id="controls">
            <button class="control-button" id="btnLeft" onclick="movePlayer(-1, 0)">⬅️</button>
            <button class="control-button" id="btnUp" onclick="movePlayer(0, -1)">⬆️</button>
            <button class="control-button" id="btnBomb" onclick="placeBomb()">💣</button>
            <button class="control-button" id="btnDown" onclick="movePlayer(0, 1)">⬇️</button>
            <button class="control-button" id="btnRight" onclick="movePlayer(1, 0)">➡️</button>
        </div>
        <div id="messageArea"></div> <!-- General game messages, not for game over -->
    </div>

    <!-- Custom Game Over Modal -->
    <div id="gameOverModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h3 id="gameOverMessage"></h3>
            <p id="gameOverScore"></p>
            <button id="restartGameButton" class="action-button">Main Lagi?</button>
        </div>
    </div>

    <script>
        const gameBoardElement = document.getElementById('gameBoard');
        const scoreElement = document.getElementById('score');
        const messageAreaElement = document.getElementById('messageArea'); // For general messages
        const bombCountElement = document.getElementById('bombCount');
        const maxBombCountElement = document.getElementById('maxBombCount');
        const bombStrengthElement = document.getElementById('bombStrength');

        const characterSelectionScreen = document.getElementById('characterSelectionScreen');
        const gameScreen = document.getElementById('gameScreen');
        const starsBackground = document.getElementById('starsBackground');
        const characterOptions = document.querySelectorAll('.character-option img');
        const confirmCharacterButton = document.getElementById('confirmCharacterButton');

        // Game Over Modal Elements
        const gameOverModal = document.getElementById('gameOverModal');
        const gameOverMessageElement = document.getElementById('gameOverMessage');
        const gameOverScoreElement = document.getElementById('gameOverScore');
        const restartGameButton = document.getElementById('restartGameButton');


        const COLS = 15;
        const ROWS = 11;
        let DYNAMIC_CELL_SIZE = 30;

        const EMPTY = 0;
        const WALL = 1;
        const DESTRUCTIBLE_WALL = 2;
        const PLAYER = 'P';
        const BOT = 'B';
        const EXPLOSION = 'E';

        const ITEM_EXTRA_BOMB = 'IB';
        const ITEM_BOMB_STRENGTH = 'IS';
        const ITEM_SCORE_BONUS = 'SB';

        const BOT_ICON_CONTENT = '👹';
        const BOMB_ICON_CONTENT = '💣';
        const EXTRA_BOMB_ICON_CONTENT = '➕';
        const BOMB_STRENGTH_ICON_CONTENT = '🔥';
        const SCORE_BONUS_ICON_CONTENT = '⭐';

        const CHARACTER_1_URL = 'img/char1.png';
        const CHARACTER_2_URL = 'img/char2.png';
        let selectedPlayerImageURL = CHARACTER_1_URL;

        let board = [];
        let player = { x: 1, y: 1, maxBombs: 1, currentActiveBombs: 0, bombStrength: 1, iconURL: selectedPlayerImageURL };
        let bots = [];
        let bombs = [];
        let score = 0;
        let gameOver = false;
        let gameStarted = false;
        let botMoveInterval;

        // --- SCREEN MANAGEMENT ---
        function showCharacterSelectionScreen() {
            characterSelectionScreen.classList.remove('hidden');
            gameScreen.classList.add('hidden');
            gameOverModal.classList.add('hidden'); // Ensure modal is hidden
            starsBackground.classList.remove('hidden');
            document.body.style.justifyContent = 'center';
        }

        function showGameScreen() {
            characterSelectionScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            gameOverModal.classList.add('hidden');
            starsBackground.classList.add('hidden');
            document.body.style.justifyContent = 'flex-start';
        }

        // --- CHARACTER SELECTION ---
        characterOptions.forEach(img => {
            img.addEventListener('click', () => {
                characterOptions.forEach(opt => opt.classList.remove('selected'));
                img.classList.add('selected');
                selectedPlayerImageURL = img.src;
                confirmCharacterButton.classList.remove('hidden');
            });
        });

        confirmCharacterButton.addEventListener('click', () => {
            showGameScreen();
            startGame();
        });

        // --- GAME INFO UPDATES ---
        function updateGameInfo() {
            scoreElement.textContent = `Skor: ${score}`;
            bombCountElement.textContent = player.maxBombs - player.currentActiveBombs;
            maxBombCountElement.textContent = player.maxBombs;
            bombStrengthElement.textContent = player.bombStrength;
        }

        // --- BOARD INITIALIZATION & RENDERING ---
        function calculateAndSetCellSize() {
            const gameInfoHeight = document.getElementById('gameInfo').offsetHeight || 60;
            const controlsHeight = document.getElementById('controls').offsetHeight || 60;
            const messageAreaHeight = document.getElementById('messageArea').offsetHeight || 35; // Adjusted message area min-height
            const verticalPadding = 25;

            const availableWidth = window.innerWidth * 0.95 - 10;
            const availableHeight = window.innerHeight - gameInfoHeight - controlsHeight - messageAreaHeight - verticalPadding;
            
            const sizeByWidth = Math.floor(availableWidth / COLS);
            const sizeByHeight = Math.floor(availableHeight / ROWS);

            DYNAMIC_CELL_SIZE = Math.max(20, Math.min(sizeByWidth, sizeByHeight, 50));
            
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.style.fontSize = Math.max(10, Math.floor(DYNAMIC_CELL_SIZE * 0.6)) + 'px';
            });
        }

        function initBoard() {
            board = Array(ROWS).fill(null).map(() => Array(COLS).fill(EMPTY));
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1) {
                        board[r][c] = WALL;
                    } else if (r % 2 === 0 && c % 2 === 0) {
                        board[r][c] = WALL;
                    } else if (Math.random() < 0.7) {
                        let isPlayerSpawnArea = (r >= player.y -1 && r <= player.y + 1 && c >= player.x -1 && c <= player.x + 1);
                        let isBotSpawnArea = bots.some(bot => (r >= bot.y -1 && r <= bot.y + 1 && c >= bot.x -1 && c <= bot.x + 1));
                        
                        if (!isPlayerSpawnArea && !isBotSpawnArea) {
                            board[r][c] = DESTRUCTIBLE_WALL;
                        }
                    }
                }
            }
            board[player.y][player.x] = EMPTY;
            if (player.x + 1 < COLS) board[player.y][player.x+1] = EMPTY;
            if (player.y + 1 < ROWS) board[player.y+1][player.x] = EMPTY;

            bots.forEach(bot => {
                if (board[bot.y] && board[bot.y][bot.x] !== undefined) board[bot.y][bot.x] = EMPTY;
                 if (bot.x + 1 < COLS && board[bot.y] && board[bot.y][bot.x+1] !== undefined) board[bot.y][bot.x+1] = EMPTY;
                 if (bot.y + 1 < ROWS && board[bot.y+1] && board[bot.y+1][bot.x] !== undefined) board[bot.y+1][bot.x] = EMPTY;
                 if (bot.x - 1 >= 0 && board[bot.y] && board[bot.y][bot.x-1] !== undefined) board[bot.y][bot.x-1] = EMPTY;
                 if (bot.y - 1 >= 0 && board[bot.y-1] && board[bot.y-1][bot.x] !== undefined) board[bot.y-1][bot.x] = EMPTY;
            });

            board[player.y][player.x] = PLAYER;
            bots.forEach(bot => {
                if(board[bot.y] && board[bot.y][bot.x] === EMPTY) board[bot.y][bot.x] = BOT;
            });
        }

        function renderBoard() {
            if (!gameBoardElement) return;
            calculateAndSetCellSize(); 

            gameBoardElement.innerHTML = '';
            gameBoardElement.style.gridTemplateColumns = `repeat(${COLS}, ${DYNAMIC_CELL_SIZE}px)`;
            gameBoardElement.style.gridTemplateRows = `repeat(${ROWS}, ${DYNAMIC_CELL_SIZE}px)`;
            gameBoardElement.style.width = `${COLS * DYNAMIC_CELL_SIZE}px`;
            gameBoardElement.style.height = `${ROWS * DYNAMIC_CELL_SIZE}px`;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    cell.style.width = `${DYNAMIC_CELL_SIZE}px`;
                    cell.style.height = `${DYNAMIC_CELL_SIZE}px`;
                    cell.style.fontSize = Math.max(10, Math.floor(DYNAMIC_CELL_SIZE * 0.6)) + 'px';

                    let content = '';
                    let isPlayerCell = false;

                    switch (board[r][c]) {
                        case WALL: cell.classList.add('wall'); break;
                        case DESTRUCTIBLE_WALL: cell.classList.add('destructible-wall'); break;
                        case PLAYER:
                            isPlayerCell = true;
                            const playerImg = document.createElement('img');
                            playerImg.src = player.iconURL;
                            playerImg.alt = "Pemain";
                            playerImg.onerror = function() {
                                this.onerror=null;
                                if(this.parentElement) {
                                    this.parentElement.innerHTML = 'P'; 
                                    this.parentElement.style.color = 'yellow';
                                }
                            };
                            cell.appendChild(playerImg);
                            break;
                        case BOT: content = BOT_ICON_CONTENT; break;
                        case ITEM_EXTRA_BOMB: content = EXTRA_BOMB_ICON_CONTENT; cell.classList.add('item'); break;
                        case ITEM_BOMB_STRENGTH: content = BOMB_STRENGTH_ICON_CONTENT; cell.classList.add('item'); break;
                        case ITEM_SCORE_BONUS: content = SCORE_BONUS_ICON_CONTENT; cell.classList.add('item'); break;
                        case EMPTY: break; 
                        case EXPLOSION: cell.classList.add('explosion'); break;
                    }

                    const bombOnCell = bombs.find(b => b.x === c && b.y === r);
                    if (bombOnCell && !isPlayerCell) {
                        content = BOMB_ICON_CONTENT;
                        cell.classList.add('bomb'); 
                        cell.style.fontSize = Math.max(12, Math.floor(DYNAMIC_CELL_SIZE * 0.75)) + 'px';
                    }
                    
                    if (!isPlayerCell) {
                        cell.innerHTML = content;
                    }
                    gameBoardElement.appendChild(cell);
                }
            }
        }

        // --- PLAYER MOVEMENT & ACTIONS ---
        window.movePlayer = function(dx, dy) {
            if (gameOver || !gameStarted) return;
            const newX = player.x + dx;
            const newY = player.y + dy;

            if (isValidMove(newX, newY)) {
                const bombAtOldPos = bombs.find(b => b.x === player.x && b.y === player.y);
                board[player.y][player.x] = bombAtOldPos ? EMPTY : EMPTY; 

                player.x = newX;
                player.y = newY;

                const cellItem = board[player.y][player.x];
                if (cellItem === ITEM_EXTRA_BOMB) {
                    player.maxBombs++;
                    showMessage("Bom ekstra didapatkan!");
                } else if (cellItem === ITEM_BOMB_STRENGTH) {
                    player.bombStrength++;
                    showMessage("Kekuatan bom bertambah!");
                } else if (cellItem === ITEM_SCORE_BONUS) {
                    score += 50;
                    showMessage("Bonus skor +50!");
                }
                
                board[player.y][player.x] = PLAYER;
                
                updateGameInfo();
                renderBoard();
                checkBotCollision();
            }
        }

        function isValidMove(x, y) {
            if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
            const targetCell = board[y][x];
            return targetCell === EMPTY || targetCell === EXPLOSION || 
                   targetCell === ITEM_EXTRA_BOMB || targetCell === ITEM_BOMB_STRENGTH || 
                   targetCell === ITEM_SCORE_BONUS || bombs.some(b => b.x === x && b.y === y);
        }

        window.placeBomb = function() {
            if (gameOver || !gameStarted) return;
            const existingBombAtPlayerPos = bombs.find(b => b.x === player.x && b.y === player.y);
            if (player.currentActiveBombs < player.maxBombs && !existingBombAtPlayerPos) {
                player.currentActiveBombs++;
                const newBomb = {
                    x: player.x,
                    y: player.y,
                    timer: setTimeout(() => explodeBomb(newBomb), 2200),
                    strength: player.bombStrength,
                    owner: PLAYER
                };
                bombs.push(newBomb);
                updateGameInfo();
                renderBoard(); 
            } else if (existingBombAtPlayerPos) {
                showMessage("Sudah ada bom di sini!");
            } else {
                showMessage("Slot bom penuh!");
            }
        }

        // --- BOMB EXPLOSION LOGIC ---
        function explodeBomb(bomb) {
            if (gameOver) return; // Don't explode if game already over
            clearTimeout(bomb.timer);
            bombs = bombs.filter(b => b !== bomb);

            if (bomb.owner === PLAYER) {
                player.currentActiveBombs = Math.max(0, player.currentActiveBombs - 1);
            }
            updateGameInfo();

            const explosionCoords = [{ x: bomb.x, y: bomb.y, isCenter: true }];
            const directions = [{dx:1, dy:0}, {dx:-1, dy:0}, {dx:0, dy:1}, {dx:0, dy:-1}];

            for (const dir of directions) {
                for (let i = 1; i <= bomb.strength; i++) {
                    const ex = bomb.x + dir.dx * i;
                    const ey = bomb.y + dir.dy * i;
                    if (!addExplosionPath(ex, ey, explosionCoords, bomb.owner)) break;
                }
            }
            
            explosionCoords.forEach(coord => {
                if (coord.x >=0 && coord.x < COLS && coord.y >=0 && coord.y < ROWS) {
                    const originalCellStateBeforeExplosion = board[coord.y][coord.x];
                    board[coord.y][coord.x] = EXPLOSION;

                    if (player.x === coord.x && player.y === coord.y) {
                        handleGameOver("Pemain terkena ledakan!");
                    }
                    bots = bots.filter(bot => {
                        if (bot.x === coord.x && bot.y === coord.y) {
                            if (bomb.owner === PLAYER) score += 100;
                            return false; 
                        }
                        return true;
                    });
                    updateGameInfo();
                    if (bots.length === 0 && gameStarted && !gameOver) {
                         handleGameOver("Semua bot dikalahkan! Kamu Menang!");
                    }
                    
                    bombs.forEach(otherBomb => { 
                        if (otherBomb.x === coord.x && otherBomb.y === coord.y && otherBomb !== bomb) {
                            setTimeout(() => { if (!gameOver) explodeBomb(otherBomb); }, 50);
                        }
                    });

                    setTimeout(() => {
                        if (gameOver) return;
                        if (board[coord.y][coord.x] === EXPLOSION) {
                            if (originalCellStateBeforeExplosion === DESTRUCTIBLE_WALL && 
                                (board[coord.y][coord.x] === ITEM_EXTRA_BOMB || 
                                 board[coord.y][coord.x] === ITEM_BOMB_STRENGTH ||
                                 board[coord.y][coord.x] === ITEM_SCORE_BONUS)) {
                                // Item revealed, do nothing
                            } else if (board[coord.y][coord.x] !== ITEM_EXTRA_BOMB &&
                                 board[coord.y][coord.x] !== ITEM_BOMB_STRENGTH &&
                                 board[coord.y][coord.x] !== ITEM_SCORE_BONUS) {
                                board[coord.y][coord.x] = EMPTY;
                            }
                        }
                        if (!gameOver) renderBoard(); // Only render if game not over
                    }, 350); 
                }
            });
            if (!gameOver) renderBoard(); 
        }

        function addExplosionPath(x, y, coordsArray, owner) {
            if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false; 
            if (board[y][x] === WALL) return false; 

            coordsArray.push({x,y}); 

            if (board[y][x] === DESTRUCTIBLE_WALL) {
                if (owner === PLAYER) score += 10;
                updateGameInfo();
                if (Math.random() < 0.5) { 
                    const itemRand = Math.random();
                    if (itemRand < 0.4) board[y][x] = ITEM_EXTRA_BOMB;
                    else if (itemRand < 0.75) board[y][x] = ITEM_BOMB_STRENGTH;
                    else board[y][x] = ITEM_SCORE_BONUS;
                } else {
                    board[y][x] = EMPTY; 
                }
                return false; 
            }
            
            if (board[y][x] === ITEM_EXTRA_BOMB || board[y][x] === ITEM_BOMB_STRENGTH || board[y][x] === ITEM_SCORE_BONUS) {
                board[y][x] = EMPTY; 
            }
            return true; 
        }
        
        // --- BOT LOGIC ---
        function moveBots() {
            if (gameOver || !gameStarted) return;
            bots.forEach(bot => {
                const moves = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
                let chosenMove = null;

                const preferredMoves = [];
                const dxPlayer = player.x - bot.x;
                const dyPlayer = player.y - bot.y;

                if (Math.abs(dxPlayer) > Math.abs(dyPlayer)) {
                    if (dxPlayer > 0) preferredMoves.push({dx:1, dy:0}); else if (dxPlayer < 0) preferredMoves.push({dx:-1, dy:0});
                    if (dyPlayer > 0) preferredMoves.push({dx:0, dy:1}); else if (dyPlayer < 0) preferredMoves.push({dx:0, dy:-1});
                } else {
                    if (dyPlayer > 0) preferredMoves.push({dx:0, dy:1}); else if (dyPlayer < 0) preferredMoves.push({dx:0, dy:-1});
                    if (dxPlayer > 0) preferredMoves.push({dx:1, dy:0}); else if (dxPlayer < 0) preferredMoves.push({dx:-1, dy:0});
                }
                moves.forEach(m => {
                    if (!preferredMoves.find(p => p.dx === m.dx && p.dy === m.dy)) preferredMoves.push(m);
                });
                
                for(const move of preferredMoves) {
                    const testX = bot.x + move.dx;
                    const testY = bot.y + move.dy;
                    if (isValidBotMove(testX, testY)) {
                        chosenMove = move;
                        break;
                    }
                }
                
                if (chosenMove) {
                    const newX = bot.x + chosenMove.dx;
                    const newY = bot.y + chosenMove.dy;
                    const bombAtOldPos = bombs.find(b => b.x === bot.x && b.y === bot.y);
                    if (board[bot.y] && board[bot.y][bot.x] !== undefined) {
                        board[bot.y][bot.x] = bombAtOldPos ? EMPTY : EMPTY;
                    }
                    bot.x = newX;
                    bot.y = newY;
                    if (board[bot.y] && board[bot.y][bot.x] !== undefined) {
                        board[bot.y][bot.x] = BOT;
                    }
                }
                checkBotCollision();
            });
            if (!gameOver) renderBoard();
        }

        function isValidBotMove(x, y) {
            if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
            if (!board[y] || board[y][x] === undefined) return false;
            const targetCell = board[y][x];
            return (targetCell === EMPTY || targetCell === ITEM_EXTRA_BOMB || targetCell === ITEM_BOMB_STRENGTH || targetCell === ITEM_SCORE_BONUS || bombs.some(b => b.x === x && b.y === y)) && targetCell !== BOT && targetCell !== PLAYER;
        }
        
        function checkBotCollision() {
            if (gameOver) return;
            bots.forEach(bot => {
                if (player.x === bot.x && player.y === bot.y) {
                    handleGameOver("Tertangkap bot!");
                }
            });
        }

        // --- GAME STATE MANAGEMENT ---
        function handleGameOver(message) {
            if (gameOver) return; 
            gameOver = true;
            gameStarted = false;
            if (botMoveInterval) clearInterval(botMoveInterval);
            
            bombs.forEach(b => clearTimeout(b.timer));
            
            messageAreaElement.textContent = ''; // Clear any general messages

            gameOverMessageElement.textContent = message;
            gameOverScoreElement.textContent = `Skor Akhir: ${score}`;
            gameOverMessageElement.style.color = message.includes("Menang") ? "#AED581" : "#FF8A80";
            
            gameOverModal.classList.remove('hidden');
        }

        restartGameButton.addEventListener('click', () => {
            gameOverModal.classList.add('hidden');
            showCharacterSelectionScreen();
            // Reset character selection UI
            characterOptions.forEach(opt => opt.classList.remove('selected'));
            confirmCharacterButton.classList.add('hidden');
            selectedPlayerImageURL = CHARACTER_1_URL; 
        });


        function showMessage(msg, duration = 2200) {
            if (gameOver) return; // Don't show general messages if game over modal is active/coming
            messageAreaElement.textContent = msg;
            setTimeout(() => {
                if (messageAreaElement.textContent === msg && !gameOver) { 
                    messageAreaElement.textContent = '';
                }
            }, duration);
        }
        
        function startGame() {
            gameStarted = true;
            gameOver = false;
            score = 0;
            
            player.x = 1;
            player.y = 1;
            player.maxBombs = 1;
            player.currentActiveBombs = 0;
            player.bombStrength = 1;
            player.iconURL = selectedPlayerImageURL; 
            
            bots = [ 
                { x: COLS - 2, y: 1, id: 1 }, 
                { x: 1, y: ROWS - 2, id: 2 }, 
                { x: COLS - 2, y: ROWS - 2, id: 3},
                { x: Math.floor(COLS / 2), y: ROWS -2, id: 4} 
            ];
            bots = bots.filter(bot => !(bot.x === player.x && bot.y === player.y) && (COLS > 5 && ROWS > 5));

            bombs.forEach(b => clearTimeout(b.timer));
            bombs = [];
            
            updateGameInfo();
            messageAreaElement.innerHTML = ''; 
            initBoard(); 
            renderBoard(); 
            updateControlsLayout(); 

            if (botMoveInterval) clearInterval(botMoveInterval);
            botMoveInterval = setInterval(moveBots, 900); 
        }

        // --- UI & CONTROLS RESPONSIVENESS ---
        function updateControlsLayout() {
            // Icons are set in HTML, this function can be expanded if dynamic text is needed.
        }

        // --- EVENT LISTENERS ---
        document.addEventListener('keydown', (event) => {
            if (!gameStarted || gameOver) { 
                if (gameOver && event.key === ' ' && !gameOverModal.classList.contains('hidden')) {
                    // Allow space to trigger "Main Lagi?" if modal is visible
                    restartGameButton.click();
                }
                return;
            }

            if ([' ', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'w', 'a', 's', 'd'].includes(event.key.toLowerCase())) {
                event.preventDefault();
            }

            switch (event.key.toLowerCase()) {
                case 'arrowup': case 'w': movePlayer(0, -1); break;
                case 'arrowdown': case 's': movePlayer(0, 1); break;
                case 'arrowleft': case 'a': movePlayer(-1, 0); break;
                case 'arrowright': case 'd': movePlayer(1, 0); break;
                case ' ': placeBomb(); break;
            }
        });

        window.addEventListener('resize', () => {
            if (gameStarted && !gameOver) {
                renderBoard(); 
            }
            updateControlsLayout(); 
        });

        // Initial setup on load
        showCharacterSelectionScreen(); 
        updateControlsLayout(); 

    </script>
</body>
</html>
